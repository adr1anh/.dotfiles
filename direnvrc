# -*- mode: sh; -*-
# Custom global configuration for [direnv](https://direnv.net/)
# i.e. override/complete the direnv-stdlib:
#           https://github.com/direnv/direnv/blob/master/stdlib.sh
#
# Quick installation of this file:
#    mkdir -p ~/.config/direnv
#    cd ~/.config/direnv
#    curl -o direnvrc https://raw.githubusercontent.com/Falkor/dotfiles/master/direnv/direnvrc
#
# Sample .envrc you can use for Python projects based on the
# layouts defined in this file:
# https://github.com/Falkor/dotfiles/blob/master/direnv/envrc
#
############################ Python ############################
# Workfow based on:
# - 'pyenv' to easily switch to a special version of python
# - 'pyenv-virtualenv' to manage python versions AND virtualenvs
#
# Typical .envrc for your python project using the below functions:
#    if [ -f ".python-version" ]; then
#       pyversion=$(head .python-version)
#    else
#       pyversion=2.7.16
#    fi
#    pvenv=$(basename $PWD)
#
#    use python ${pyversion}
#    layout virtualenv ${pyversion} ${pvenv}
#    layout activate ${pvenv}
#
# Adapted from
#  - https://github.com/direnv/direnv/wiki/Python#-pyenv and
#  - https://github.com/direnv/direnv/wiki/Python#-virtualenvwrapper
#  - https://github.com/direnv/direnv/wiki/Python#venv-stdlib-module
#
# Side note:
# It appeared required to reload the pyenv [virtualenv-]init as for
# It May be due to the fact that direnv is creating a new bash
#  sub-process to load the stdlib, direnvrc and .envrc
###

# === Use a specific python version (with pyenv) ===
# Usage in .envrc:
#    use python <version>
use_python() {
    if has pyenv; then
        local pyversion=$1
        eval "$(pyenv init -)"
        pyenv local ${pyversion} || log_error "Could not find pyenv version '${pyversion}'. Consider running 'pyenv install ${pyversion}'"
    fi
}


# === Create a new virtualenv ===
# Usage in .envrc:
#    layout virtualenv <version> <name>
layout_virtualenv() {
    local pyversion=$1
    local pvenv=$2
    if has pyenv; then
        if [ -n "$(which pyenv-virtualenv)" ]; then
            export PYENV_VIRTUALENV_DISABLE_PROMPT=1
            eval "$(pyenv virtualenv-init -)"
            pyenv virtualenv --quiet ${pyversion} ${pvenv}
            # pyenv virtualenv --force --quiet ${pyversion} ${pvenv}
        else
            log_error "pyenv-virtualenv is not installed."
        fi
    elif has python3; then
        # Use venv by default
        layout_python-venv ${pvenv}
    else
        log_error "pyenv or python3 venv not found."
    fi

}

# === Activate a virtualenv ===
# Note that pyenv-virtualenv uses 'python -m venv' if it is
# available (CPython 3.3 and newer) and  'virtualenv' otherwise
# Usage in .envrc:
#    layout activate <name>
layout_activate() {
    if has pyenv; then
        # local pyenvprefix=$(pyenv prefix)
        # local pyversion=$(pyenv version-name)
        local pvenv="$1"
        # Below initialization is necessary to recall ;(

        pyenv activate ${pvenv}
    else
        source ${VIRTUAL_ENV}/bin/activate
    fi
}


layout_anaconda() {
  local ACTIVATE="/usr/local/anaconda3/bin/activate"

  if [ -n "$1" ]; then
    # Explicit environment name from layout command.
    local env_name="$1"
    source $ACTIVATE ${env_name}
  elif (grep -q name: environment.yml); then
    # Detect environment name from `environment.yml` file in `.envrc` directory
    source $ACTIVATE `grep name: environment.yml | sed -e 's/name: //' | cut -d "'" -f 2 | cut -d '"' -f 2`
  else
    (>&2 echo No environment specified);
    exit 1;
  fi;
}